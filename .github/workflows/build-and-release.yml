name: Build and Release Stasis

on:
  push:
    tags:
      - 'v*' # Trigger on tags like v1.0.0
  workflow_dispatch:
    inputs:
      version_tag:
        description: 'Version to build (e.g. 1.0.0) without "v" prefix'
        required: true
        default: '0.1.0'

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-pc-windows-msvc

      - name: Install Python tools
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller

      - name: Install Python dependencies
        run: pip install -r requirements.txt

      - name: Determine Dynamic Version
        id: versioning
        shell: pwsh
        run: |
          $VERSION = "0.0.0"
          if ($env:GITHUB_REF -match "^refs/tags/v(.*)") {
              # If triggered by a tag push (e.g. "refs/tags/v1.0.0"), extract "1.0.0"
              $VERSION = $matches[1]
          } elseif ('${{ github.event_name }}' -eq 'workflow_dispatch') {
              # If manually triggered, use input string
              $VERSION = '${{ github.event.inputs.version_tag }}'
              # Remove "v" if user accidentally typed it
              $VERSION = $VERSION -replace '^v', ''
          } else {
              # Fallback for dynamic versions to be unique per build
              $VERSION = "0.1.${{ github.run_number }}"
          }
          Write-Output "Extracted version: $VERSION"
          echo "APP_VERSION=$VERSION" >> $env:GITHUB_ENV

      - name: Inject Dynamic Version
        shell: pwsh
        run: |
          $VERSION = $env:APP_VERSION
          Write-Output "Setting app version to $VERSION"

          # Use Node to cleanly parse and update JSON files
          node -e "
          const fs = require('fs');
          const version = process.env.APP_VERSION;
          
          // Update tauri.conf.json
          const tauriPath = 'frontend/src-tauri/tauri.conf.json';
          const tauriConf = JSON.parse(fs.readFileSync(tauriPath));
          tauriConf.version = version;
          fs.writeFileSync(tauriPath, JSON.stringify(tauriConf, null, 4));
          
          // Update package.json
          const pkgPath = 'frontend/package.json';
          const pkg = JSON.parse(fs.readFileSync(pkgPath));
          pkg.version = version;
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2));
          "

          # Update Cargo.toml using Powershell regex
          $CargoToml = "frontend/src-tauri/Cargo.toml"
          $cargoContent = Get-Content $CargoToml
          $cargoContent = $cargoContent -replace '^(version\s*=\s*")([^"]+)(")', "`${1}$VERSION`${3}"
          $cargoContent | Set-Content $CargoToml
          
          Write-Output "Version updated successfully in all config files!"

      - name: Run Build Script (build.ps1)
        shell: pwsh
        run: |
          # build.ps1 does exactly what we do locally (builds pyinstaller, runs npm install, runs tauri build) 
          .\build.ps1

      - name: Upload GitHub Release
        uses: softprops/action-gh-release@v2
        if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
        with:
          tag_name: v${{ env.APP_VERSION }}
          name: Stasis v${{ env.APP_VERSION }}
          draft: false
          prerelease: false
          files: |
            frontend/src-tauri/target/release/bundle/nsis/*.exe
            frontend/src-tauri/target/release/bundle/nsis/*.msi
            frontend/src-tauri/target/release/bundle/zip/*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
